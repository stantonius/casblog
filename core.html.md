# core


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

docs for fasthtml & jupyter: https://fastht.ml/docs/api/jupyter.html

## Setup

``` python
# fc_tool_info()
```

Tools available from `fastcore.tools`:

- &`rg`: Run the `rg` command with the args in `argstr` (no need to
  backslash escape)
- &`sed`: Run the `sed` command with the args in `argstr` (e.g for
  reading a section of a file)
- &`view`: View directory or file contents with optional line range and
  numbers
- &`create`: Creates a new file with the given content at the specified
  path
- &`insert`: Insert new_str at specified line number
- &`str_replace`: Replace first occurrence of old_str with new_str in
  file
- &`strs_replace`: Replace for each str pair in old_strs,new_strs
- &`replace_lines`: Replace lines in file using start and end
  line-numbers

``` python
from fastcore.tools import *
```

------------------------------------------------------------------------

<a
href="https://github.com/stantonius/casblog/blob/main/casblog/core.py#L26"
target="_blank" style="float:right; font-size:smaller">source</a>

### find_project_root

>  find_project_root ()

*Walk up from cwd or **file** to find project root (has settings.ini)*

## Config

## Database

does the above check if plash_production exists or is truthy?

##### ğŸ¤–ReplyğŸ¤–<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ 

It checks if the environment variable **exists and is non-empty** â€” but
it doesnâ€™t check if the value is specifically `"true"` or `"1"`.

`os.getenv("PLASH_PRODUCTION")` returns: - `None` if the env var doesnâ€™t
exist - The string value if it does exist (even if itâ€™s `"false"` or
`"0"`)

So setting `PLASH_PRODUCTION=false` would actually be **truthy** and use
`prod.db`!

If you want to check for a specific truthy value, youâ€™d do something
like:

``` python
os.getenv("PLASH_PRODUCTION", "").lower() in ("1", "true", "yes")
```

Is that the behavior you intended, or do you want to tighten it up?

### Dataclasses

------------------------------------------------------------------------

<a
href="https://github.com/stantonius/casblog/blob/main/casblog/core.py#L67"
target="_blank" style="float:right; font-size:smaller">source</a>

### Post

>  Post (title:str, content:str, slug:str=None,
>            created:datetime.datetime=None, updated:datetime.datetime=None,
>            categories:str='[]', id:int=None)

**Categories approach (keeping it simple):**

Weâ€™re storing categories as a JSON string in each post (e.g.,
`'["Tech", "Life"]'`). On each page load, we:

1.  Fetch all posts from the DB
2.  Parse each postâ€™s categories JSON
3.  Flatten and dedupe to get the full category list

**Why this â€œinefficientâ€ approach?**

- A personal blog will likely have \<100 posts â€” this is trivially fast
- Avoids complexity of caching logic or extra tables
- Easier to reason about and debug
- No premature optimization â€” optimize when (if) it becomes a problem

**Future optimization options (if needed):**

- Cache categories in memory, refresh on post create/update/delete
- Separate `categories` table maintained alongside posts

``` python
# Test slug generation
p = Post(title="Hello World!", content="test")
assert p.slug == "hello-world", f"Expected 'hello-world', got '{p.slug}'"

# Test special characters in slug
p2 = Post(title="What's Up?? @#$ Test", content="test")
assert p2.slug == "what-s-up-test", f"Expected 'what-s-up-test', got '{p2.slug}'"

# Test created timestamp auto-set
p3 = Post(title="Timestamp Test", content="test")
assert p3.created is not None, "created should be auto-set"
assert isinstance(p3.created, datetime), "created should be a datetime"

# Test update method
p4 = Post(title="Update Test", content="original")
p4.update(content="modified", title="New Title")
assert p4.content == "modified", "content should be updated"
assert p4.title == "New Title", "title should be updated"
assert p4.updated is not None, "updated should be set after update()"
assert p4.slug == "update-test", "slug should NOT change without regenerate_slug=True"

# Test slug regeneration
p5 = Post(title="Original Title", content="test")
p5.update(title="Brand New Title", regenerate_slug=True)
assert p5.slug == "brand-new-title", f"Expected 'brand-new-title', got '{p5.slug}'"

# Test default categories
p6 = Post(title="No Categories", content="test")
assert p6.categories == "[]", f"Expected '[]', got '{p6.categories}'"

# Test categories passed as list (note: your dataclass stores as-is, not auto-JSON)
p7 = Post(title="With Categories", content="test", categories='["Tech", "Life"]')
assert p7.categories == '["Tech", "Life"]', "categories should store the JSON string"

# Test updating categories
p8 = Post(title="Category Update", content="test")
p8.update(categories='["New", "Updated"]')
assert p8.categories == '["New", "Updated"]', "categories should be updatable"

# Test explicit slug is NOT overwritten
p_custom_slug = Post(title="My Title", content="test", slug="my-custom-slug")
assert p_custom_slug.slug == "my-custom-slug", "Explicit slug should be preserved"

# Test explicit created is NOT overwritten  
custom_date = datetime(2020, 1, 15)
p_custom_date = Post(title="Old Post", content="test", created=custom_date)
assert p_custom_date.created == custom_date, "Explicit created date should be preserved"


print("Category tests passed! âœ“")
```

    Category tests passed! âœ“

## Helpers

------------------------------------------------------------------------

<a
href="https://github.com/stantonius/casblog/blob/main/casblog/core.py#L93"
target="_blank" style="float:right; font-size:smaller">source</a>

### get_all_categories

>  get_all_categories ()

*Get all unique categories across all posts.*

``` python
# Use isolated test database (don't touch dev.db)
_original_db = db
db = database(":memory:")
db.create(Post)

# Insert posts with various category combinations
db.t.post.insert(Post(title="Post 1", content="test", categories='["Tech", "Life"]'))
db.t.post.insert(Post(title="Post 2", content="test", categories='["Tech", "Travel"]'))
db.t.post.insert(Post(title="Post 3", content="test", categories='[]'))  # empty categories
db.t.post.insert(Post(title="Post 4", content="test", categories='["Life"]'))

# Test: should return sorted unique categories
result = get_all_categories()
assert result == ["Life", "Tech", "Travel"], f"Expected sorted unique cats, got {result}"

# Test: empty db should return empty list
db.t.post.drop(ignore=True)
db.create(Post)
assert get_all_categories() == [], "Empty db should return empty list"

# Restore original db
db = _original_db

print("get_all_categories tests passed! âœ“")
```

------------------------------------------------------------------------

<a
href="https://github.com/stantonius/casblog/blob/main/casblog/core.py#L103"
target="_blank" style="float:right; font-size:smaller">source</a>

### get_posts_by_category

>  get_posts_by_category (category)

*Get all posts that include the given category.*

``` python
# Use isolated test database (don't touch dev.db)
_original_db = db
db = database(":memory:")
db.create(Post)

db.t.post.insert(Post(title="Post 1", content="test", categories='["Tech", "Life"]'))
db.t.post.insert(Post(title="Post 2", content="test", categories='["Tech"]'))
db.t.post.insert(Post(title="Post 3", content="test", categories='["Travel"]'))

# Test: find posts with "Tech" category
result = get_posts_by_category("Tech")
assert len(result) == 2, f"Expected 2 Tech posts, got {len(result)}"

# Test: category with no posts
assert get_posts_by_category("Nonexistent") == [], "Should return empty list for missing category"

# Test: single match
assert len(get_posts_by_category("Travel")) == 1, "Should find 1 Travel post"

# Restore original db
db = _original_db

print("get_posts_by_category tests passed! âœ“")
```

------------------------------------------------------------------------

<a
href="https://github.com/stantonius/casblog/blob/main/casblog/core.py#L109"
target="_blank" style="float:right; font-size:smaller">source</a>

### format_date

>  format_date (dt:str)

``` python
# Test standard datetime string
assert format_date("2024-03-15T10:30:00") == "15 March 2024"

# Test date-only string
assert format_date("2023-12-01") == "01 December 2023"

# Test with microseconds
assert format_date("2025-01-07T14:22:33.123456") == "07 January 2025"

test_fail(format_date, args=1234, exc=TypeError)

test_fail(format_date, args=['not-a-date'], exc=ValueError)

print("format_date tests passed! âœ“")
```

    format_date tests passed! âœ“

Calling `db.t.post()` returns `dict`, not a
[`Post`](https://stantonius.github.io/casblog/core.html#post) object.
Which means we have to convert string datetimes ourselves

------------------------------------------------------------------------

<a
href="https://github.com/stantonius/casblog/blob/main/casblog/core.py#L113"
target="_blank" style="float:right; font-size:smaller">source</a>

### get_post_by_slug

>  get_post_by_slug (slug)

``` python
# Use isolated test database (don't touch dev.db)
_original_db = db
db = database(":memory:")
db.create(Post)

db.t.post.insert(Post(title="Test Post", content="hello", slug="test-post"))

# Test: find existing post
result = get_post_by_slug("test-post")
assert result is not None
assert result['title'] == "Test Post"

# Test: non-existent slug returns None
assert get_post_by_slug("nope") is None

# Restore original db
db = _original_db

print("get_post_by_slug tests passed! âœ“")
```

#### ToC Nav Helpers

------------------------------------------------------------------------

<a
href="https://github.com/stantonius/casblog/blob/main/casblog/core.py#L118"
target="_blank" style="float:right; font-size:smaller">source</a>

### extract_headers

>  extract_headers (md_content)

*Extract headers from markdown, return list of (level, text, slug).*

------------------------------------------------------------------------

<a
href="https://github.com/stantonius/casblog/blob/main/casblog/core.py#L146"
target="_blank" style="float:right; font-size:smaller">source</a>

### render_md_with_ids

>  render_md_with_ids (md_content)

*Render markdown and add IDs to headers for scrollspy.*

## Components

------------------------------------------------------------------------

<a
href="https://github.com/stantonius/casblog/blob/main/casblog/core.py#L167"
target="_blank" style="float:right; font-size:smaller">source</a>

### sidebar

>  sidebar ()

------------------------------------------------------------------------

<a
href="https://github.com/stantonius/casblog/blob/main/casblog/core.py#L186"
target="_blank" style="float:right; font-size:smaller">source</a>

### theme_toggle

>  theme_toggle ()

*Single button theme toggle - shows sun in dark mode, moon in light
mode.*

------------------------------------------------------------------------

<a
href="https://github.com/stantonius/casblog/blob/main/casblog/core.py#L200"
target="_blank" style="float:right; font-size:smaller">source</a>

### navbar

>  navbar ()

------------------------------------------------------------------------

<a
href="https://github.com/stantonius/casblog/blob/main/casblog/core.py#L214"
target="_blank" style="float:right; font-size:smaller">source</a>

### layout

>  layout (content, show_sidebar=True)

------------------------------------------------------------------------

<a
href="https://github.com/stantonius/casblog/blob/main/casblog/core.py#L232"
target="_blank" style="float:right; font-size:smaller">source</a>

### toc_nav

>  toc_nav (headers)

## Routes

------------------------------------------------------------------------

<a
href="https://github.com/stantonius/casblog/blob/main/casblog/core.py#L244"
target="_blank" style="float:right; font-size:smaller">source</a>

### index

>  index ()

------------------------------------------------------------------------

<a
href="https://github.com/stantonius/casblog/blob/main/casblog/core.py#L262"
target="_blank" style="float:right; font-size:smaller">source</a>

### cat

>  cat (category:str)

------------------------------------------------------------------------

<a
href="https://github.com/stantonius/casblog/blob/main/casblog/core.py#L281"
target="_blank" style="float:right; font-size:smaller">source</a>

### post

>  post (slug:str)

------------------------------------------------------------------------

<a
href="https://github.com/stantonius/casblog/blob/main/casblog/core.py#L314"
target="_blank" style="float:right; font-size:smaller">source</a>

### about

>  about ()

visit the blog in prod:
https://cas-stantonius-site.pla.sh/post/how-to-read#reply-4

do you see all of the â€˜ğŸ¤–ReplyğŸ¤–â€™ that are converted to headers in the
ToC? why does the parser keep these in?

##### ğŸ¤–ReplyğŸ¤–<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ 

<details class="tool-usage-details">

``` json
{
  "id": "toolu_01PJ4rvwHVroLXSeRuRHLaKn",
  "call": {
    "function": "read_url",
    "arguments": {
      "url": "https://cas-stantonius-site.pla.sh/post/how-to-read"
    }
  },
  "result": "'[Home](/)[About](/about)\\n\\n### [Cas Stantonius ](/)\\n\\n#### Categories\\n\\n[LLMs](/cat/LLMs)[Personal Development](/cat/Personal%20Development)\\n\\n# How to Read\\n\\nPublished 14 December 2025\\n\\n# How to Read\\n\\nResources:\\n\\n  * [Farnham Street\\'s summary of How to Read a Book](https://fs.blog/how-to-read-a-book/)\\n\\n\\n\\nI have a problem. I feel like I have to memorize non-fiction books, which causes me to either read slow or avoid reading altogether out of fear of what I am missing.\\n\\nMy guess is this stems from seeing \\'photographic memory\\' folks read something once and be able to recite <TRUNCATED>"
}
```

</details>

I can see the issue clearly. Looking at the ToC on the page, there are
many `ğŸ¤–ReplyğŸ¤–` entries showing up as headers.

The problem is in your
[`extract_headers`](https://stantonius.github.io/casblog/core.html#extract_headers)
function. Let me check the filtering logic:

``` python
# Skip headers that are mostly emoji/special chars (no alphanumeric content)
if not re.search(r'[a-zA-Z0-9]', text_clean):
    continue
```

The filter checks if thereâ€™s **any** alphanumeric content. But
`ğŸ¤–ReplyğŸ¤–` contains the word â€œReplyâ€ â€” which **does** have alphanumeric
characters (`R`, `e`, `p`, `l`, `y`). So it passes the filter!

The regex `[a-zA-Z0-9]` matches â€œReplyâ€, so the header is kept.

**Options to fix:**

1.  **Explicitly skip headers matching a pattern** â€” e.g., skip any
    header thatâ€™s just `ğŸ¤–ReplyğŸ¤–`
2.  **Require a minimum amount of alphanumeric content** â€” e.g., â€œmust
    be \>50% alphanumericâ€
3.  **Use a blocklist** â€” skip headers containing certain phrases like
    â€œReplyâ€ surrounded by emoji

Which approach feels right for your use case? Do you want to filter out
*all* `ğŸ¤–ReplyğŸ¤–` headers, or is there a more general rule youâ€™d prefer?

yes I want all of these out always

##### ğŸ¤–ReplyğŸ¤–<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ 

Got it â€” you want to filter out all the `ğŸ¤–ReplyğŸ¤–` headers from the
ToC.

The simplest fix is to add a check that skips headers matching that
pattern. Hereâ€™s the line to add right after the `text_clean` processing:

``` python
# Skip reply markers
if re.search(r'ğŸ¤–.*Reply.*ğŸ¤–', text):
    continue
```

Add this inside
[`extract_headers`](https://stantonius.github.io/casblog/core.html#extract_headers),
just before the `base_slug` line. Youâ€™ll also need the same check in
[`render_md_with_ids`](https://stantonius.github.io/casblog/core.html#render_md_with_ids)
if you want consistency (though for the ToC, only
[`extract_headers`](https://stantonius.github.io/casblog/core.html#extract_headers)
matters).

Want me to show the full updated function, or do you want to try adding
it yourself?

show me the full updated function

##### ğŸ¤–ReplyğŸ¤–<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ 

Hereâ€™s the updated
[`extract_headers`](https://stantonius.github.io/casblog/core.html#extract_headers)
function:

``` python
def extract_headers(md_content):
    """Extract headers from markdown, return list of (level, text, slug)."""
    headers = []
    slug_counts = Counter()
    in_code_block = False
    for line in md_content.split('\n'):
        if line.strip().startswith('```') or line.strip().startswith('~~~'):
            in_code_block = not in_code_block
            continue
        if not in_code_block and (m := re.match(r'^(#{1,6})\s+(.+)$', line)):
            level, text = len(m.group(1)), m.group(2).strip()
            # Strip HTML comments (both encoded and raw forms)
            text_clean = re.sub(r'<!--.*?-->', '', text)
            text_clean = re.sub(r'&lt;!--.*?--&gt;', '', text_clean).strip()
            # Skip reply markers
            if re.search(r'ğŸ¤–.*Reply.*ğŸ¤–', text):
                continue
            # Skip headers that are mostly emoji/special chars (no alphanumeric content)
            if not re.search(r'[a-zA-Z0-9]', text_clean):
                continue
            base_slug = re.sub(r'[^a-z0-9]+', '-', text_clean.lower()).strip('-')
            slug_counts[base_slug] += 1
            slug = base_slug if slug_counts[base_slug] == 1 else f"{base_slug}-{slug_counts[base_slug]}"
            headers.append((level, text_clean, slug))
    return headers
```

The key addition is the `if re.search(r'ğŸ¤–.*Reply.*ğŸ¤–', text): continue`
block that skips any header containing the reply marker pattern.

I was concerned that using SQLite would be slower than using static
files to store blog posts. After thinking about it though, it seems that
sqlite *is a local file* that we are reading. There is no network
latency, and because sqlite *is a single file*, reads are super fast.
Therefore there is no real difference in storing static markdown files
vs storing their content in the sqlite db.

## Development

``` python
# db.t.post.drop(ignore=True)
```

``` python
server = JupyUvi(app)
```

Go to Solveit dashboard and click â€˜Copy Public URLâ€™ button to getâ€¦public
URL to see any app running (by default port 8000)

``` python
server.stop()
```

## System Design

ah there is a `/data` dir in my project root that `pla.sh` uses. Docs
are [here](https://docs.pla.sh/explains/data_storage.html)

Important to note - they do auto backups so you can restore if something
goes haywire: https://docs.pla.sh/how_to/restore_backups.html

What I eventually want: write a dialog and export via code to the /data
dir (or do I? Im not even sure)

I just want a more streamlined way to post blogs.

Right now, the only way I can do this with minimal effort is to export
to a markdown gist, then process the gist to extract the md content and
put it in the db.

Need a backup solution at some point. Canâ€™t keep a production db within
solveit that I risk overwriting (even though plash does have a restore
option in worst case)

ok so lets say I use the /data folder in my project root to write blog
posts. Id want to have a nbs dir within in for ipynb files and also a
posts dir which contains the posts that I convert from ipynb to md. does
this make sense?

##### ğŸ¤–ReplyğŸ¤–<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ 

Yes, that makes sense! So your structure would be:

    project_root/
    â”œâ”€â”€ data/
    â”‚   â”œâ”€â”€ dev.db
    â”‚   â”œâ”€â”€ prod.db
    â”‚   â”œâ”€â”€ nbs/          # Author notebooks here
    â”‚   â”‚   â””â”€â”€ my-post.ipynb
    â”‚   â””â”€â”€ posts/        # Converted markdown
    â”‚       â””â”€â”€ my-post.md

The workflow would be: write in `nbs/`, convert to `posts/`, then load
from `posts/` into the sqlite db.

A couple of questions to clarify your intent:

1.  **Why both `posts/` and sqlite?** Are you thinking the md files are
    the â€œsource of truthâ€ and you periodically sync them into the db? Or
    is the db the source of truth once imported?

2.  **Conversion tool** â€” are you planning to use `nbdev` or
    `jupyter nbconvert` to go from ipynb â†’ md?

its a fair question. sqlite allows for quick indexing and grouping based
on categories?

##### ğŸ¤–ReplyğŸ¤–<!-- SOLVEIT_SEPARATOR_7f3a9b2c -->

ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ ğŸ§ 

Exactly right! SQLite gives you:

- **Fast queries** â€” filter by category, date ranges, search by title,
  etc.
- **Indexing** â€” add indexes on `slug`, `categories`, etc. for even
  faster lookups
- **Relationships** â€” if you ever want tags, comments, or other linked
  data

So the markdown files in `posts/` would be your **source of truth**
(easy to version control, edit in any text editor), and the sqlite db is
your **runtime cache** for fast querying.

The workflow would be: 1. Write/edit in `nbs/` as notebooks 2. Convert
to markdown â†’ `posts/` 3. Run a sync script that reads `posts/*.md` and
upserts into sqlite

Does that match what youâ€™re thinking? And do you want the sync to be
manual (run a command) or automatic (detect file changes)?

## Deploying

Using https://pla.sh/dashboard

you need to create a requirements.txt file based on the above packages.
use your tools to get the current packages versions. generate this
requirements.txt file in the parent folder of this file

``` python
!pip show python-fasthtml fastlite monsterui fastcore fastlucide | grep -E "^(Name|Version)"
```

    Name: python-fasthtml
    Version: 0.12.36
    Name: fastlite
    Version: 0.2.2
    Name: monsterui
    Version: 1.0.35
    Name: fastcore
    Version: 1.9.2
    Name: fastlucide
    Version: 0.0.6

## Export
